package main

import "fmt"

func NotMain() {
	fmt.Println("Arrays")

	// Инициализация массива
	// По умолчанию массивы инициализируются нулями
	// Массивы в Go имеют фиксированную длину, которая указывается при объявлении
	// Массивы могут содержать элементы одного типа, например int, string и т.д.

	var arr0 [5]int = [5]int{1, 2, 3, 4, 5} // Инициализация массива с указанием длины
	var arr1 [5]int
	arr2 := [5]int{1, 2, 3, 4, 5}
	arr3 := [...]int{1, 2, 3, 4, 5}          // Длина массива определяется автоматически
	arr4 := [5]int{1: 10, 3: 30}             // Индексы 1 и 3 инициализируются, остальные - нулями
	var x = [12]int{1, 5: 4, 6, 10: 100, 15} // [1, 0, 0, 0, 0, 4, 6, 100, 0, 0, 0, 15]

	//Доступ к элементам массива и их изменение
	arr1[0] = 1
	arr1[1] = 2

	// Массивы можно сравнивать с помощью == и !=
	// Массивы сравниваются поэлементно
	// Если все количество элементов и их значения равны, то массивы равны

	// Хоть в го есть одномерные массивы, но их можно использовать как многомерные
	// Например, двумерный массив можно представить как массив массивов

	var y [2][3]int // Двумерный массив 2x3
	// Официально в го нет многомерных массивов

	// При чтении и записи нельзя выходить за пределы массива, как и использовать отриц. индекс
	// Такие ошибки отлаживаются на этапе компиляции
	// Если использовать переменную, то компилятор не сможет проверить выход за границы
	// В таком случае программа выдаст "панику" в рантайме

	lenght := len(arr0) // len() встроенная функция, принимает массив и возвращает его длину
	// cap() возвращает емкость массива, но для массивов она равна длине

	// ВАЖНО: в Go у массивов необычное ограничение
	// РАЗМЕР массива является частью его типа
	// [3]int и [4]int - это разные типы
	// Поэтому нельзя задействовать переменную для указания размера массива,
	// поскольку типы должны определяться на этапе компиляции
	// Также нельзя приобразовать массив одного типа в другой

	fmt.Println(arr0, arr1, arr2, arr3, arr4, x, y, lenght)

}
