package main

import "fmt"

func main() {
	fmt.Println("Display")

	// Мапы (на русском "ОТОБРАЖЕНИЯ", фу), по сути, словари, key-value pair, наверное, я ещё не дочитал
	//EDIT: да эт они :)

	// синтаксис map[типКлюча]типЗначения
	var nilMap map[string]int // ключ типа string, значение типа int
	// Нулевым значением мапы(отображения) - является nil, длина nil-мапы = 0
	// Чтение nil-мапы вернёт нулевое значение value-типа. КАРОЧ ЕСЛИ В ПАРЕ ЗНАЧЕНИЕ ТИПА ИНТ, ТО ВЕРНЁТ 0
	// ЕСЛИ BOOL ТО FALSE, ЕСЛИ СТРОКА ТО "" И Т.П.
	// Запись в nil-мапу вернёт панику

	// Объявление через := позволяет создать переменную отображения путём
	// присвоения ей литерала отображения
	// (Я тоже нихрена не понял, ну типа, пустой литерал отображения тут в виде '{}')
	totalWins := map[string]int{}
	// созданное таким образом мапа отличается от равного nil
	// Длина его тоже равна 0, однако, для него допустимы операции чтения и записи

	// Не пустой литерал отображения выглядит вот так
	teams := map[string][]string{
		"Orcas":   []string{"Fred", "Ralph", "Bijou"},
		"Lionas":  []string{"Sarah", "Peter", "Billie"},
		"Kittens": []string{"Waldo", "Raul", "Ze"},
	}
	fmt.Println(nilMap, totalWins, teams)
	// В теле литерала используется знак ':' который отделяет ЗНАЧЕНИЕ и КЛЮЧ
	// После каждой пары ключ:значение ставится запятая, даже после последней (лол)
	// В качестве значений мапы можно использовать любой тип. Ограничения есть только у ключей

	// Если заранее известно сколько будет пар, но нет инфы о какие конкретно это будут,
	// то можно создать мапу с помощью функции MAKE, они будут иметь нулевую длину
	// а рост не ограничен изначально указанным размером
	ages := make(map[int][]string, 10)
	fmt.Println(ages)

	// В Go мапы реализованы через хэш-функции/хэш-таблицы
	// Реализация хэш-функций находится в среде выполнения Go

	// У мапов много общего со срезами:
	// Динамически расширяются, можно заранее указать размерность,
	// Можно узнать сколько k-v пар содержится в мапе через len
	// Являются не сравнимым типом (Кроме сравнения на nil)

	// Ключ мапы обязан быть сравнимого типа, т.е. ключом не могут быть срезы
	// Чтоб обратиться к значению по ключу - испольховать '[ИНДЕКС]'
	// Чтоб присвоить значение по ключу - использовать '=' (:= НЕЛЬЗЯ)
	// Попытка прочесть неприсвоенное значение вернёт нулевое значение
	// Попытка прочесть ключ которого не существует в мапе - вернёт нулевое значение (Ваааааат, а зачем)

	// Идиома "Запятая-ok"
	// Помогает проверить есть ли ключ в мапе
	// Полезно когда нужно узнать, возвращается тебе 0 потому что по ключу именно значение 0
	// или просто такого ключа не сущесвует (Ну вот как по мне дичь какая-то, лучше б просто выкидывало
	// панику что нет такого ключа, хз хз не нравится вообще)

}
