package main

import "fmt"

func main() {
	fmt.Println("MAPS")

	// Мапы (на русском "ОТОБРАЖЕНИЯ", фу), по сути, словари, key-value pair, наверное, я ещё не дочитал
	//EDIT: да эт они :)

	// синтаксис map[типКлюча]типЗначения
	var nilMap map[string]int // ключ типа string, значение типа int
	// Нулевым значением мапы(отображения) - является nil, длина nil-мапы = 0
	// Чтение nil-мапы вернёт нулевое значение value-типа. КАРОЧ ЕСЛИ В ПАРЕ ЗНАЧЕНИЕ ТИПА ИНТ, ТО ВЕРНЁТ 0
	// ЕСЛИ BOOL ТО FALSE, ЕСЛИ СТРОКА ТО "" И Т.П.
	// Запись в nil-мапу вернёт панику

	// Объявление через := позволяет создать переменную отображения путём
	// присвоения ей литерала отображения
	// (Я тоже нихрена не понял, ну типа, пустой литерал отображения тут в виде '{}')
	totalWins := map[string]int{}
	// созданное таким образом мапа отличается от равного nil
	// Длина его тоже равна 0, однако, для него допустимы операции чтения и записи

	// Не пустой литерал отображения выглядит вот так
	teams := map[string][]string{
		"Orcas":   []string{"Fred", "Ralph", "Bijou"},
		"Lionas":  []string{"Sarah", "Peter", "Billie"},
		"Kittens": []string{"Waldo", "Raul", "Ze"},
	}
	fmt.Println(nilMap, totalWins, teams)
	// В теле литерала используется знак ':' который отделяет ЗНАЧЕНИЕ и КЛЮЧ
	// После каждой пары ключ:значение ставится запятая, даже после последней (лол)
	// В качестве значений мапы можно использовать любой тип. Ограничения есть только у ключей

	// Если заранее известно сколько будет пар, но нет инфы о какие конкретно это будут,
	// то можно создать мапу с помощью функции MAKE, они будут иметь нулевую длину
	// а рост не ограничен изначально указанным размером
	ages := make(map[int][]string, 10)
	fmt.Println(ages)

	// В Go мапы реализованы через хэш-функции/хэш-таблицы
	// Реализация хэш-функций находится в среде выполнения Go

	// У мапов много общего со срезами:
	// Динамически расширяются, можно заранее указать размерность,
	// Можно узнать сколько k-v пар содержится в мапе через len
	// Являются не сравнимым типом (Кроме сравнения на nil)

	// Ключ мапы обязан быть сравнимого типа, т.е. ключом не могут быть срезы
	// Чтоб обратиться к значению по ключу - испольховать '[ИНДЕКС]'
	// Чтоб присвоить значение по ключу - использовать '=' (:= НЕЛЬЗЯ)
	// Попытка прочесть неприсвоенное значение вернёт нулевое значение
	// Попытка прочесть ключ которого не существует в мапе - вернёт нулевое значение (Ваааааат, а зачем)

	// Идиома "Запятая-ok"
	// Помогает проверить есть ли ключ в мапе
	// Полезно когда нужно узнать, возвращается тебе 0 потому что по ключу именно значение 0
	// или просто такого ключа не сущесвует (Ну вот как по мне дичь какая-то, лучше б просто выкидывало
	// панику что нет такого ключа, хз хз не нравится вообще)
	// Выглядит она так:

	m := map[string]int{
		"hello": 5,
		"world": 0,
	}
	v, ok := m["hello"]
	fmt.Println(v, ok)
	v, ok = m["world"]
	fmt.Println(v, ok)
	v, ok = m["goodbye"]
	fmt.Println(v, ok)

	// С помощью этой идиомы результат чтения мапы присваиваются двум переменным.
	// В первую заносится значение по ключу, во второй булево значение существование ключа

	// Удалить из мапы (отображения прсти хспде)
	// Для удаления из мапы используется встроенная функция delete()

	delete(m, "hello")
	// На вход принимается мапа(отображение) и ключ, по которому нужно удалить kvp(key-value pair)
	// Если указанного ключа не существует или мапа = nil, то ничего не происходит
	// delete() не возвращает значение

	// clear() работает и с мапами
	// Длина мапы становится равна нулю ну и очевидно очищает мапу

	// В версии 1.21 в стандартную библиотеку добавлен спец. пакет maps,
	// который добавляет вспомогательный функционал для работы с мапами
	// например в них есть maps.Equal и maps.EqualFunc, работают аналогично версиям для слайсов

	// МНОЖЕСТВА
	// в Go их нет
	// ОДНАКО, можно имитировать их поведение с помощью мапов
	//

}
