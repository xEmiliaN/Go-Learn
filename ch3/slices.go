package main

import (
	"fmt"
	"slices"
)

func Notmain() {
	fmt.Println("Slices")

	// Срезы в Go - это динамические массивы
	// Они могут изменять свой размер во время выполнения программы.
	// Их длина не является составной частью типа, как в случае с массивами.

	// Инициализация среза | Важно подметить []int - срез, [...]int - массив
	s1 := []int{10, 20, 30} // Слайс(срез) с 3 элементами

	// анлгично массиву можно создать срез нулевыми индексами или указать какие элементы не нулевые
	s2 := []int{0: 10, 1: 20, 2: 30}
	s3 := []int{1, 5: 4, 6, 10: 100, 15} // [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]

	// Имитация многомерного среза
	var s4 [][]int
	// Для чтения и записи элементов используются [], прямо как и в массивах
	// Очевидно, надеюсь, что и выходить за пределы среза не получится и будет ошибка
	// либо компидяции лиюо рантайма

	// Инициализация среза без использования литерала
	var s5 []int
	// нулевым значением среза является nil, а не пустой массив
	// nil - это специальное значение, которое указывает на отсутствие значения.
	// как нетипизированные числовые константы, значение nil не имеет типа,
	// что позволяет присваивать или сравнивать его с любым типом данных.
	// Срез равный nil не содержит элементов.
	// Срез является несравнительным типом. Попытки узнать равны ли два среза приведут к ошибке
	// компиляции. Их можно сравнивать только с nil.

	fmt.Println(s1, s2, s3, s4, s5)

	// С версии 1.21 пакет slices стандартной библиотеки включает в себя две функции
	// для сравнения срезов: Equal и EqualFunc.
	// 1-я принимает два среза и возвращает true, если у них одинаковая длина и элементы равны.
	// Для этого требуется, чтобы элементы срезов были сравнимыми.
	// 2-я позволяет передать функцию для определения равенства, и не требует,
	// чтобы элементы были сравнимыми. Она возвращает true, если все элементы равны.

	x := []int{1, 2, 3, 4, 5}
	y := []int{1, 2, 3, 4, 5}
	z := []int{1, 2, 3, 4, 5, 6}
	s := []string{"a", "b", "c"}

	fmt.Println("Equal:", slices.Equal(x, y)) // true
	fmt.Println("Equal:", slices.Equal(x, z)) // false
	// fmt.Println("Equal:", slices.Equal(x, s)) // не компилируется, т.к. разные типы

	// До этой версии Go для сравнения срезов использовался пакет reflect, функция DeepEqual.
	// Это предназначется для тестирования, а не для сравнения срезов в реальных приложениях.
	// НЕ НУЖНО ЕЁ ИСПОЛЬЗОВАТЬ, она медленнее и менее безопасна.
	fmt.Println(s)

	// Встроенная функция len возвращает длину среза. Если срез равен nil, то len(s) == 0.
	// len существует, так как выполняемые действия невозможно осуществить с помощью функций,
	// написанных обычным образом.

	// Встроенная функция append используется для добавления элементов в срез.
	// Она принимает срез и один или несколько элементов, которые нужно добавить.
	// var x []int
	// x = append(x, 1) // добавляет 1 в конец среза x
	// Принимает минимум два параметра: срез и элемент, который нужно добавить.
	// Возвращает новый срез, тип которого равен типу первого параметра.
	// За один раз можно добавить несколько элементов, передав их через запятую.

	// Один срез добавляется в другой срез с помощью ... (троеточие).
	// y := []int{1, 2, 3}
	// x = append(x, y...) // добавляет элементы y в конец среза x

	// Написать append без переменной, которая будет хранить результат - нельзя, ошибка компиляции.
	// В Go используется передача по значению, а не по ссылке.
	// Когда мы передаём параметр в функцию, Go создаёт копию передаваемого значения.
	// Поэтому, если мы просто добавим элемент в срез, то он не изменится, т.к.
	// append получает копию среза, а затем создаёт новый срез и возвращает его,
	// а не изменяет существующий.

	// Для создания пустого среза
	// (который не равен nil, и все элементы проиницализированы стандартными значениями)
	// используется встроенная функция make.
	// Она принимает три параметра: тип, длину и ёмкость.

	b := make([]int, 5) // создаёт срез длиной 5 и ёмкостью 5 (т.к. не указана ёмкость)
	fmt.Println(b)      // [0 0 0 0 0]
	// Частая ошибка после создания среза с помощью make - попытка добавить элементы в него,
	// через append.

	// b = append(b, 1, 2, 3)
	// в этом случае у нас итак есть 5 элементов, и мы добавляем ещё 3 элемента В КОНЕЦ
	// поэтому после make достаточно обращаться к элементам через [индекс]
	// append только если необходимо увеличить и добавить в конец элемент

	// Можно например создать срез у которого длина 0 а вместимость 10.
	// Тогда у нас будет срез не равный nil, и при этом не имеющий даже нулевых значений
	// Таким образом в него можно будет добавлять элементы через append
	// (Я хз что быстрее, создать срез с нулевыми значениями и изменять индексы, или
	// создать срез определённой ёмкости и добавлять элементы через append)

	// В версии Go 1.21 добавлена встроенная функция clear, которая принимает срез
	// устанавливает значения всех элементов в дефолтное/нулевое значение.
	// Длина среза остаётся той же

}
