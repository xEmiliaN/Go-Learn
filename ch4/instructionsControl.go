package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println("if")
	// синтаксис самый узнаваемый, заключать условие в круглые скобки ненада

	n := rand.Intn(10)
	fmt.Println(n)

	if n == 0 {
		fmt.Println("zero")
	} else if n > 5 {
		fmt.Println("big")
	} else {
		fmt.Println("nice number")
	}

	// уникальная особенность в том, что можно объявить переменные сразу в блоке условия

	if m := rand.Intn(10); m == 0 {
		fmt.Println("zero")
	} else if m > 5 {
		fmt.Println("big")
	} else {
		fmt.Println("nice number")
	}
	// данная m определена только для всех блоков if else, случайно обратиться к ней условия
	// невозможно

	// Очевидно такое объявление будет затенять объявленные переменные блоком выше

	fmt.Println("For")
	/*
		for - единственный способ организации циклов.
		(while здесь нет, это просто уникальный for)
		Всего 4 вида for:
		1) полный, стиле языка C
		2) for использующий только условие
		3) бесконечный for
		4) оператор for-range
	*/

	// Полный for
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}
	// Использование var для объявления переменной не допускается, только :=.
	// Переменные тут также затеняются

	// For с 1 условием
	j := 1
	for j < 100 {
		fmt.Println(j)
		j *= 2
	}
	// самый обычный while

	// Бесконечный for
	// не запускай это
	for {
		fmt.Println("Hello")
		break
	}
	// по сути просто бесконечный while
	// существуют ключевые слова break и continue, выполняют всё то же самое что и везде

	// while do версии нет, но можно использовать бесконечный for в конце которого условие которое
	// просто вызовет break

	// идиоматически в Go считается использовать как можно меньше вложенных if, ну и с минимальным телом

	// for-range
	// По своей сути - это итератор (foreach C#). Обходит элементы одного из встроенных типов языка (Массивы, слайсы, строки, мапы (ещё и каналы))

	// Цикл for-range можно использовать только для обхода встроенных составных типов или основанных них пользовательских типов (не оч пока понимаю)

	evenVals := []int{2, 4, 6, 8, 10, 12}
	for i, v := range evenVals {
		fmt.Println(i, v)
	}

	/* 	Особнность - две переменные цикла
	Первая - текущая позиция в структуре данных, которую обходим.
	Вторая - само значение этой позиции.
	Идиоматически наименование переменных зависит от структуры которуб обходим. Если это Массивы слайсы и т.п., то i - индекс, v - value, значение. В мапе вместо i будет k, ключ.

	Для длинных или вложенных циклов желательно использовать длинные имена, для небольшого прохода - достаточно коротких буковок.
	*/

	// Можно пропустить объявление некоторых переменных с помощью '_'

	for _, v := range evenVals {
		fmt.Println(v)
	}
	// МЫСЛИ: т.е. как бы for range итак будет проходится по структуре, мы объявляем переменные которые будут работать именно со структурой. Можно вообще ничего не объявлять, тогда цикл выполнится столько раз, сколько элементов в структуре, ха, прикол

	// можно опустить значение и оставить только индекс/ключ

	uniqueNames := map[string]bool{"Fred": true, "Raul": true, "Wilma": true}
	for k := range uniqueNames {
		fmt.Println(k)
	}

	// Стоит заметить, порядок обхода мапов - случайный, это просто их особенность, т.к. у нас это не совсем упорядоченная структура

	m := map[string]int{
		"a": 1,
		"b": 2,
		"c": 3,
	}
	for i := 0; i < 3; i++ {
		fmt.Println("Loop", i)
		for k, v := range m {
			fmt.Println(k, v)
		}
	}

	// кароч все эти приколы были созданы больше для усложнения провдения DoS-атак на основе хеш-колизий (к сожалению я ещё пока не особо разбираюсь в этом т.к. полноценный сервер не писал)

	// Обход строки
	// for-range также используется и для обхода строк

	samples := []string{"hello", "apple_π!"}
	for _, sample := range samples {
		for i, r := range sample {
			fmt.Println(i, r, string(r))
		}
		fmt.Println()
	}

	// Итак, прикол такой, особенность использованя for range со строками в том, цикл перебирает не БАЙТЫ а РУНЫ.
	// Всякиий раз, когда цикл встречает в строке руну из нескольких байтов, он преобразовывает его представление в формате UTF-8 в одно 32-разрядное число и присваивает его переменной.
	// Смещение при этом увеличивается на то, количество байт, которое содержится в руне. Когда цикл for-range встречает байт, который не является значение UTF-8, вместо него возвращается символ Unicode (16-тиричное значение)

	// Цикл for-range копирует значения элементов, при обходе любого составного типа. Т.е. изменение значения переменной не приведёт ни к какому изменению элемента составного типа.
	// В версиях ДО(!) go 1.22 переменная value создаётся всего лишь один раз и используется повторно на каждой итерации цикла for.
	// Начиная с версии Go 1.22, по умолчанию на каждой итерации цикла for, создаётся новый индекс и новое значение переменной.
	// break и continue прилагается

	// ОПЕРАТОРЫ FOR С МЕТКАМИ(эт чё за херня?)
	// Кароч, break и continue работают только на циклы внутри которого они находятся. А что если нужно выйти прям сразу и из верхнего? Для этого есть тема под названием метка

	samples2 := []string{"hello", "apple_π!"}
memes: //название метки может быть любым
	for _, sample := range samples2 {
		for i, r := range sample {
			fmt.Println(i, r, string(r))
			if r == 'l' {
				continue memes
			}
		}
		fmt.Println()
	}

	// вложенные циклы редко снабжаются метками

	// В большинстве случаев следует применять оператор for-range, если эти самые случаи подразумевают обход коллекции. (ОСОБЕННО ДЛЯ СТРОК, ИХ ВСЕГДА ВСЕГДА ТОЛЬКО for-range)

	// ОПЕРАТОР SWITCH

	words := []string{"a", "cow", "smile", "gopher", "octopus", "anthropologist"}
	for _, word := range words {
		switch size := len(word); size {
		case 1, 2, 3, 4:
			fmt.Println(word, "is a short word")

		case 5:
			wordLen := len(word)
			fmt.Println(word, "is exactly the right lenght:", wordLen)
		case 6, 7, 8, 9:
		default:
			fmt.Println(word, "is a long word!")
		}
	}

	// как и с if - не нужно заключать условие в скобки
	// можно объявить переменную область видимости которой будет включать в себя все ветви оператора switch. В данном случае объявлена переменная size, которая видеа всем ветвям.

	// все ветви заключены в фигурные скобки. В каждой ветви можно засунуть неесколько строк кода. Проваливания нет, break в конце каждой ветви не нужен. Если нужно чтоб несколько значений запускали абсолютно одинаковую логику, достаточно просто через запятую передать все значения которые должны выполнять схожую логику.
	// в теории есть ключевое словое falltrough, однако если кажется что оно нужно, то лучше пересмотреть решения в своей жизни и задуматься...
	// Переключение происходит на основе целочисленного значения, но это можно делать и на основе любого другого типа, который можно сранивать с помощью оператора ==. (Все встроенные типы кроме срезов, мапов, каналов, функций и структур полями этих типов)
	// break не запрещено использовать, если вдруг нужно выйти из ветви раньше

}
